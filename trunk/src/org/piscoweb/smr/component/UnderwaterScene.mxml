<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas clipContent="true" borderStyle="none" horizontalScrollPolicy="off" verticalScrollPolicy="off" borderThickness="1" xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" xmlns:component="org.piscoweb.smr.component.*">
	<mx:Script>
		<![CDATA[
			import mx.logging.Log;
			import mx.effects.Effect;
			import mx.events.EffectEvent;
			import mx.effects.Fade;
			import org.cove.ape.VectorForce;
			import mx.events.ItemClickEvent;
			import mx.events.IndexChangedEvent;
			import mx.controls.ToggleButtonBar;
			import org.cove.ape.CircleParticle;
			import mx.controls.Alert;
			import mx.collections.ArrayCollection;
			import org.cove.ape.Vector;
			import org.piscoweb.smr.data.DataPoint;
			import org.piscoweb.smr.data.Organism;
			import mx.core.UIComponent;
			import org.piscoweb.smr.data.Location;
			import flash.filters.ColorMatrixFilter;
			
			[Bindable]
			private var _selectedDataPoint:DataPoint;
			
			public static const BEFORE:String = '1';
			public static const AFTER:String = '0';
			public static const MAX_START_FISH:int = 10;
			
			public static const FLOW_INTERVAL:int = 500;
			private var flowTimer:Timer;
			private var fishMoveTimer;
			
			private var panels:Array = [];
			private var particleCount:int = 0;
			
			private var transitioning:Boolean = false;
			private var state:String;
			private var particles:Array = new Array();
			private var _location:Location;
			
			[Embed(source="../assets/pisco.swf")]
			public static const Logo:Class;
			[Embed(source="../assets/pisco-small.swf")]
			public static const PiscoSmall:Class;
			
			private var dataPointSequence:Array;
			private var dataPointSequenceIndex:int;
						
//			private var dim:ColorMatrixFilter = new ColorMatrixFilter([0.3086, 0.6094, 0.0820, 0, 0, 0.3086, 0.6094, 0.0820, 0, 0, 0.3086, 0.6094, 0.0820, 0, 0, 0, 0, 0, 1, 0]);
			
			[Bindable]
			public function set location(location:Location):void
			{
				_location = location;
				this.addChildAt(location.background, 0);
//				_location.background.content.stage.frameRate = 15;
				fishTank.start();
				loadData();
				flowTimer = new Timer(500, 500000);
//				trace(flowTimer);
				for each(var dataPoint:DataPoint in location.dataPoints){
					var panel:dataPointStatusPanel = new dataPointStatusPanel();
					panel.location = location;
					panel.dataPoint = dataPoint;
					panel.x = 0;
					panel.y = panel.height * -1;
					fishTank.addChild(panel);
					this.panels.push(panel);
				}
//				500 * 5 = 2500 seconds or 41 minutes
				flowTimer.addEventListener(TimerEvent.TIMER, changeFlow);
				flowTimer.start();
				
				fishMoveTimer = new Timer(500, 500000);
				fishMoveTimer.addEventListener(TimerEvent.TIMER, moveFish);
				fishMoveTimer.start();
			}
			
			private function moveFish(event:TimerEvent):void
			{
				if((rand(0, 10) % 2) == 0){
					var particle:APEOrganismParticle = APEOrganismParticle(particles[rand(0, particles.length)]);
					var x:Number
					var vec:VectorForce
					if(particle.organism.org_type == "algae"){
						
					}
					else if(particle.organism.org_type == "invertebrate"){
						x = rand(-4, 4);
						if(rand(0,3)==2) vec = new VectorForce(false, x, rand(2, 0));
						else vec = new VectorForce(false, x, 0);
						if(x >= 0){
							particle.direction = APEOrganismParticle.RIGHT;
						}else{
							particle.direction = APEOrganismParticle.LEFT;
						}
						particle.addForce(vec);
					}
					else{
						x = rand(-40, 40);
						vec = new VectorForce(false, x, rand(-10, 11));
						if(x >= 0){
							particle.direction = APEOrganismParticle.RIGHT;
						}else{
							particle.direction = APEOrganismParticle.LEFT;
						}
						particle.addForce(vec);
					}
				}else{
//					trace('not adding movement');
				}
			}
			
			private function changeFlow(event:TimerEvent):void
			{
				var flow:VectorForce = new VectorForce(false, rand(-10, 10), rand(-0.5, 1));

				for each(var particle:APEOrganismParticle in this.particles){
					if(particle.organism.org_type == "invertebrate" || particle.organism.org_type == "algae"){
						
					} 
					else{
						particle.addForce(flow);
					}
				}
			}
			
			[Bindable]
			public function set selectedDataPoint(dataPoint:DataPoint):void
			{
				_selectedDataPoint = dataPoint;
				for each(var panel:dataPointStatusPanel in this.panels){
					panel.display = (panel.dataPoint == _selectedDataPoint);
				}
				
				if(dataPoint != null){
					for each(var particle:APEOrganismParticle in this.particles){
						if(particle.dataPoint == dataPoint){
							particle.displayObject.filters = [orgDropShadow];
						}else{
							particle.displayObject.filters = [orgBlur];
						}
					}
					fishTank.pause();
					blur.stop();
					blur.play();
					fishMoveTimer.stop();
					flowTimer.stop();
					_location.pauseBg();
				}else{
					this.selectedDataPoint = null;
					fishMoveTimer.start();
					flowTimer.start();
					for each(var particle:APEOrganismParticle in this.particles){
						particle.displayObject.filters = [];
					}
					fishTank.resume();
					if(blur.isPlaying){
						blur.reverse();
					}else{
						blur.play(null, true);
					}
					_location.resumeBg();
				}
			}
			
			public function get selectedDataPoint():DataPoint
			{
				return _selectedDataPoint;
			}
			
			public function pause():void
			{
				fishTank.pause();
				_location.pauseBg();
			}
			
			public function resume():void
			{
				fishTank.resume();
				_location.resumeBg();
			}

			private function loadData():void
			{
				var dataPoints:ArrayCollection = location.dataPoints;
				var num_fish_left:int = Math.round(MAX_START_FISH * location.scaleAbundance);
//				trace("num_fish_left: " + num_fish_left);
				var org_types:Array = new Array();
				for(var i:int=0;i<dataPoints.length;i++){
					var orgs:ArrayCollection = DataPoint(dataPoints[i]).organisms;
					for each(var org:Organism in orgs){
						org_types.push(org);
					}
				}
				var num_per_org:int = Math.round(num_fish_left / org_types.length);
//				trace('num_per_org_type: ' + num_per_org);
				
				for each(var dataPoint:DataPoint in location.dataPoints){
					for each(var organism:Organism in dataPoint.organisms){
						var beforeNumber:int = Math.round(num_per_org * organism.relativeAbundance);
//						trace('num-per-org * org.relativeAbundance: ' + beforeNumber); 
						if(beforeNumber ==0){ beforeNumber = 1;}
//						trace('change to 1 if under 1: '+beforeNumber);
//						trace('this many instances of '+organism.name+' will be place in BEFORE: '+beforeNumber);
						var afterNumber:int = Math.round(beforeNumber * dataPoint.density);
						if(dataPoint.density == -1) afterNumber = beforeNumber; //this is because "-1" is a special character
//						trace('this many instances of '+organism.name+' will be place in AFTER: '+afterNumber);
//						var diff:int = afterNumber - beforeNumber;
//						trace('difference: '+diff);
						var total:int = afterNumber;
						if(beforeNumber > afterNumber){total = beforeNumber}
//						trace('total '+organism.name+': '+total);
						var afterCount:int = 0;
						var beforeCount:int = 0;
						var displayBefore:Boolean = false;
						var displayAfter:Boolean = false;
						for(var i:int=0; i < total; i++){
							if(afterCount < afterNumber){
								displayAfter = true;
								afterCount = afterCount + 1;
							}else{
								displayAfter = false;
							}
							if(beforeCount < beforeNumber){
								displayBefore = true;
								beforeCount = beforeCount + 1;
							}else{
								displayBefore = false;
							}
//							trace('displayBefore, displayAfter: '+displayBefore, displayAfter);
							var particle:APEOrganismParticle = createParticle(organism, displayBefore, displayAfter, dataPoint);
							this.particles.push(particle);
						}
					}
				}
				
				this.startBeforeState();
			}
			
			private function createParticle(organism:Organism, before:Boolean, after:Boolean, dataPoint:DataPoint):APEOrganismParticle
			{
				var x:int
				var y:int
				x = rand(this.width * 0.10, this.width - this.width * 0.10);
				
				
				if(organism.org_placement == "below"){
					x = rand(this.width * 0.05, this.width * 0.95);
					y = rand(organism.placement_horizon + organism.horizon_angle*x, this.height* 0.85);
				}
				else if (organism.org_placement == "above"){
					x = rand(this.width * 0.05, this.width * 0.95);
					y = rand(this.height * 0.10, organism.placement_horizon - organism.horizon_angle*x);
				}
				else{
					x = rand(this.width * 0.10, this.width * 0.90);
					y = rand(this.height * 0.10, this.height * 0.90);
				}
//				trace(x,y);
				var particle:APEOrganismParticle = new APEOrganismParticle(x, y, organism, location.orgScale);
				particle.displayBefore = before;
				particle.displayAfter = after;
				particle.dataPoint = dataPoint;
				dataPoint.particles.push(particle);
				
				
				this.particleCount += 1;
//				trace(this.particleCount);
				// probably don't need to start them with a random vector
				// when flow is simulated
//				particle.velocity = new Vector(rand(-1, 1), rand(-1, 0));
				return particle;
			}
			
			private function orgMouseOver(e:Event):void
			{
				if(this.state == AFTER && !this.transitioning){
					this.selectedDataPoint = APEOrganismParticle(e.target).dataPoint;
				}
				
			}
			
			private function orgMouseOut(e:Event):void
			{
				if(this.state == AFTER && !this.transitioning){
					this.selectedDataPoint = null;
				}
			}
			
			private function rand(min:Number, max:Number):Number
			{
				return Math.floor(Math.random() * (max - min)) + min;
			}
			
			public function get location():Location
			{
				return _location;
			}
			
			private function startBeforeState():void
			{
				for each(var particle:APEOrganismParticle in this.particles){
					if(particle.displayBefore){
						this.addParticle(particle);
					}else{
						this.removeParticle(particle);
					}
				}
				this.state = BEFORE;
			}
			
			private function changeState(toState:String):void
			{
				trace(toState);
				if(toState == BEFORE){
					if(this.state != BEFORE){
						this.transitioning = true;
//						trace('changing state to BEFORE');
						for each(var particle:APEOrganismParticle in this.particles){
							if(particle.inWater){
//								trace('found a particle in the water', particle.organism.name);
								if(!particle.displayBefore){
//									trace('!displayBefore, removing');
									this.fishTank.removeParticle(particle);
								}else{
//									trace('particle in water but also to be displayed before');
								}
							}else{
//								trace('particle not in water', particle.organism.name);
								if(particle.displayBefore){
//									trace('displayBefore == true, adding');
									this.addParticle(particle);
								}
							}
							particle.changeSize(1, false);
						}
						this.transitioning = false;
						this.state = toState;
					}
				}else if(toState == AFTER){
					if(this.state != AFTER){
						this.transitioning = true;
//						trace('changing state to AFTER');
//						this.attractToCenter();
//						this.fishTank.waitThenCall(completeChangeToAfterState, 10);
//						trace('---------------------------------');
						completeChangeToAfterState();
					}
				}else{
					throw('holy cow');
				}
			}
			
			private function completeChangeToAfterState():void
			{
//				trace('completeChangeToAfterState');
				this.dataPointSequence = this.location.dataPoints.toArray();
				this.dataPointSequenceIndex = 0;
				transitionDataPointToAfter();
			}
			
			private function transitionDataPointToAfterFadeOut(e:EffectEvent):void
			{
//				trace('fadeOut callback');
				Effect(e.target).removeEventListener(EffectEvent.EFFECT_END, transitionDataPointToAfterFadeOut);
				var dataPoint:DataPoint = this.dataPointSequence[this.dataPointSequenceIndex - 1];
				for each(var p:APEOrganismParticle in dataPoint.particles){
					if(!p.displayAfter){
						this.fishTank.removeParticle(p);
					}
				}
				this.transitionDataPointToAfter(e);
			}
			
			private function transitionDataPointToAfter(e:Object=null):void
			{
				if(e){
					if(e.type == TimerEvent.TIMER){
						Timer(TimerEvent(e).target).removeEventListener(TimerEvent.TIMER, transitionDataPointToAfter);
					}else{
						Effect(EffectEvent(e).target).removeEventListener(EffectEvent.EFFECT_END, transitionDataPointToAfter);
					}
				}
//				trace('dataPointSequence: '+this.dataPointSequence);
//				trace(this.dataPointSequence[this.dataPointSequenceIndex]);
				if(this.dataPointSequenceIndex < this.dataPointSequence.length){
//					trace('still data points to handle');
					var dataPoint:DataPoint = DataPoint(this.dataPointSequence[this.dataPointSequenceIndex]);
//					this.selectedDataPoint = dataPoint;
					var fadeOut:Fade = new Fade();
					fadeOut.alphaFrom = 1;
					fadeOut.alphaTo = 0;
					fadeOut.duration = 3;
					var fadeIn:Fade = new Fade();
					fadeIn.alphaFrom = 0;
					fadeIn.alphaTo = 1;
					fadeIn.duration = 1000;
					var newSize:Number = dataPoint.getAdjustedSize();
					for each(var particle:APEOrganismParticle in dataPoint.particles){
						if(particle.inWater){
							if(!particle.displayAfter){
//								this.fishTank.removeParticle(particle);
//								trace('pushing fadeOut.targets');
//								fadeOut.targets.push(particle.displayObject);
								this.fishTank.removeParticle(particle);
							}else{
//								trace('changing size of particle already in water');
								particle.changeSize(newSize, false);
							}
						}else{
							if(particle.displayAfter){
								particle.hide();
								fadeIn.targets.push(particle.displayObject);
//								trace('adjustedSize: ' +dataPoint.getAdjustedSize());
								// not animating for now, as animation does not work
								particle.changeSize(newSize, false);
								this.addParticle(particle);
							}
						}
					}
					this.dataPointSequenceIndex = this.dataPointSequenceIndex + 1;
					if(fadeOut.targets.length > 0){
//						trace('fadeOut.targets.length > 0');
//						fadeOut.addEventListener(EffectEvent.EFFECT_END, transitionDataPointToAfterFadeOut);
//						fadeOut.play();
						transitionDataPointToAfter();
					}else if(fadeIn.targets.length > 0){
//						fadeIn.addEventListener(EffectEvent.EFFECT_END, transitionDataPointToAfter);
						transitionDataPointToAfter();
						fadeIn.play();
					}else{
//						trace('making 3 second timer');
//						var t:Timer = new Timer(3000, 0);
//						t.addEventListener(TimerEvent.TIMER, transitionDataPointToAfter);
//						t.start();
						transitionDataPointToAfter();
					}
//					this.selectedDataPoint = null;
				}else{
//					trace('no more dataPoints to handle');
					this.selectedDataPoint = null;
					this.dataPointSequenceIndex = 0;
					this.dataPointSequence = null;
					this.transitioning = false;
					this.state = AFTER;
				}
			}
			
			
			private function removeParticle(particle:APEOrganismParticle):void
			{
				this.fishTank.removeParticle(particle);
			}
			
			private function orgClick(e:Event):void
			{
//				trace('org click', e.target);
				if(location.caseStudyUrl){
					navigateToURL(new URLRequest(location.caseStudyUrl));
				}
			}
			
			private function addParticle(particle:APEOrganismParticle):void
			{
				if(!particle.alreadyLoaded){
					particle.addEventListener(APEOrganismParticle.MOUSE_OVER, orgMouseOver);
					particle.addEventListener(APEOrganismParticle.MOUSE_OUT, orgMouseOut);
					particle.addEventListener(APEOrganismParticle.CLICK, orgClick);
					particle.alreadyLoaded = true;
				}
				if(particle.loaded){
					this.fishTank.addParticle(particle);
				}else{
					particle.addEventListener(APEOrganismParticle.LOADED, this.finishAdding);
				}
			}
			
			private function finishAdding(e:Event):void
			{
				this.addParticle(APEOrganismParticle(e.target));
			}
			
			private function handleToggleBar(e:Event):void
			{
//				if(this.transitioning){
//					trace('transitioning');
//					if(e.index != int(state)){
////						stateButton.selectedIndex = 0;
//					}else{
//						if(e.index == 1){
//							stateButton.selectedIndex = 0;
//						}else{
//							stateButton.selectedIndex = 1;
//						}
//					}
//				}else{
//					if(ToggleButtonBar(e.target).selectedIndex == 0){
//						this.changeState(BEFORE);
//					}else{
//						this.changeState(AFTER);
//					}
//
//				}
				if(this.state == BEFORE){
					this.changeState(AFTER);
					instructions.htmlText = afterText + citationLink();
					Button(e.target).label = "Reset";
				}else{
					this.changeState(BEFORE);
					instructions.text = beforeText;
					Button(e.target).label = "protect this site";
				}
			}
			
			private function citationLink():String
			{
				
				var citation:String = DataPoint(location.dataPoints[0]).citation;
				var url:String;
				// <stevenColbertBossVoice>
				// Haha! ugly hack
				// </stevenColbertBossVoice>			
				
				if (DataPoint(location.dataPoints[0]).direct_link != ""){
					url = DataPoint(location.dataPoints[0]).direct_link;
				}
				else if(citation == 'a Forthcoming PISCO Publication'){
					url = "http://www.piscoweb.org/research/community/subtidal";
				}else{
					url = "http://scholar.google.com/scholar?hl=en&lr=&btnG=Search&q=";
					var url:String = url + escape(citation);
				}
				
				return '<font color="#ccccff"><u><a href="'+url+'" target="_blank">'+citation+'</a></u></font>';
			}
			
			public function attractToCenter():void
			{
//				var center:Point = new Point(this.width/2, this.height/2);
//				
//				for each(var p:APEOrganismParticle in this.particles){
//					if(p.inWater){
//						var vector:VectorForce = new VectorForce(false, center.x - p.px, center.y - p.py);
//						p.velocity = new Vector(0, 0);
//						p.addForce(vector);
//					}
//				}
			}
		]]>
	</mx:Script>
	<mx:String id="beforeText">Press the button to see how a Marine Reserve changed this site</mx:String>
	<mx:String id="afterText">Point to an organism for more information. Data from </mx:String>
	<component:APEFishTank width="100%" height="100%" id="fishTank" >
	</component:APEFishTank>
<!--	<mx:ToggleButtonBar id="stateButton" x="80" y="390" alpha="90" itemClick="handleToggleBar(event)" styleName="buttonBarButton">
		<mx:dataProvider>
			<mx:String>Before</mx:String>
			<mx:String>After Reserve Establishment</mx:String>
		</mx:dataProvider>
	</mx:ToggleButtonBar> -->
	<mx:DropShadowFilter id="orgDropShadow" alpha="1" angle="64.34" blurX="14.30" blurY="10.34" distance="4.0" strength="1" quality="{1.11}" />
	<mx:Blur duration="100" blurXFrom="0" blurXTo="15" blurYFrom="0" blurYTo="15" target="{location.background}" id="blur" />
	<mx:BlurFilter id="orgBlur" blurX="15" blurY="15" />
	<mx:Canvas id="bottomPanel" width="100%" verticalScrollPolicy="off" horizontalScrollPolicy="off" height="46" bottom="0" >
		<mx:HBox verticalAlign="middle" height="100%" width="100%" paddingLeft="5" paddingTop="5" paddingBottom="5" paddingRight="5" verticalCenter="0" left="0" borderColor="#062F4C" backgroundColor="#051A25" backgroundAlpha="0.81">
			<mx:LinkButton height="30" width="40" click="navigateToURL(new URLRequest('http://www.piscoweb.org'))" icon="{PiscoSmall}" themeColor="#000000" enabled="true">
				<mx:toolTip>Created by the Partnership for Interdisciplinary Studies of Coastal Oceans
				www.piscoweb.org
				</mx:toolTip>
			</mx:LinkButton>
			<mx:Text fontFamily="Arial" fontSize="11" id="instructions" width="90%" color="#F1FDFF">
				<mx:text>{beforeText}</mx:text>
			</mx:Text>
			<mx:Button alpha="0.97" fontSize="10" click="handleToggleBar(event)" label="protect this site" width="115" top="10" themeColor="#009DFF" enabled="true">
			</mx:Button>
		</mx:HBox>
	</mx:Canvas>
</mx:Canvas>
